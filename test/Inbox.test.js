// contract test code will go here
const assert = require('assert');
const ganache = require('ganache-cli');
// Capital casing of W refers to constructor
const Web3 = require('web3');
//Lower casing of w refers to instace
const web3 = new Web3(ganache.provider());
const { interface, bytecode } = require('../compile');

//Variable that will hold the 10 random accounts generated by ganache.
let getAccounts;
//Variable that will hold our deployed contract on lines 21-23.
//This variable is our javaScript representation of the contract we deploy on lines 21-23.
let inbox;

//This variable will allow us to set and store the initial string needed in our inbox contract.
const INITIAL_STRING = 'Hi there';

beforeEach(async () => {
    // Get a list of all Accounts
    getAccounts = await web3.eth.getAccounts();

    //Use one of these contracts to deploy the contracts

    {/*The following lines of code are tied to the web3 library 
which is our sole means of intereacting with the ETH network. Our portal to Ethereum*/}
    //inbox is instance of the contract, a javascript object that represents the contract that exists on the block chain.
    inbox = await new web3.eth.Contract((JSON.parse(interface)))
        .deploy({ data: bytecode, arguments: [INITIAL_STRING] })
        .send({ from: getAccounts[0], gas: '1000000' });
});

describe('Inbox', () => {
    it('deploys a contract', () => {
        //TEST 1
        //ok method on assert insures that the value we pass in exists.
        //Simple test like this is great for ensuring that our deployment process is working correctly
        assert.ok(inbox.options.address);
    });

    // The following test checks that we always pass a default message to our contract
    //We are going to call a method on our inbox contract

    it('has a default message', async () => {
        //inbox is instance of the contract, a javascript object that represents the contract that exists on the block chain.
        {/*
        inbox has property called '.methods'. 
        '.methods' is an object that contains all of the different public functions that exists in our contract.
        So in our inbox contract this would give us access to 2 methods: message() and setMessage()
    */}
        // so this value retrieves our message
        const message = await inbox.methods.message().call();


        //Now we need to assert the value of our message.
        assert.equal(message, INITIAL_STRING);
    });

    it('can change the message', async () => {
       await inbox.methods.setMessage('bye').send({ from: getAccounts[0] });
       const message = await inbox.methods.message().call();
       assert.equal(message, 'bye');
    });
});